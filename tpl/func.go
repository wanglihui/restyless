package tpl

import (
	"html/template"
	"io"
	"strings"
)

type FuncData struct {
	Name          string
	URL           string
	InterfaceName string
	Params        []string
	Returns       []string
}

func FuncTemplate(dst io.Writer, data FuncData) {
	var tpl = `
func (it *{{.InterfaceName}}) {{.Name}} ({{.ParamStr}}) ({{.ReturnStr}}) {
	var e httperror.HTTPError
	r := it.r.R().SetError(e)
	{{if .Headers}}r = r.SetHeaders({{.Headers}}){{end}}
	{{if .Body}}r = r.SetBody({{.Body}}){{end}}
	{{if .Query}}r = r.SetQuery({{.Query}}){{end}}
	{{if .ReturnStruct}}
	var ret {{.ReturnStruct}}
	r = r.SetResult(&ret)
	_, err := r.{{.Method}}("{{.URL}}")
	return ret, err
	{{else}}
	_, err := r.{{.Method}}("{{.URL}}")
	return err
	{{end}}
}
`
	type comData struct {
		FuncData
		ReturnStr    string
		ParamStr     string
		ReturnStruct string
		Headers      string
		Query        string
		Body         string
		Method       string
	}
	d := comData{
		FuncData:  data,
		ReturnStr: strings.Join(data.Returns, ","),
		ParamStr:  strings.Join(data.Params, ","),
	}
	if len(data.Returns) == 2 {
		d.ReturnStruct = data.Returns[0]
	}
	method := "Get"
	if strings.Contains(data.Name, "Post") {
		method = "Post"
	} else if strings.Contains(data.Name, "Del") {
		method = "Delete"
	} else if strings.Contains(data.Name, "Put") {
		method = "Put"
	}
	d.Method = method
	for _, v := range data.Params {
		if strings.Contains(v, "headers=") {
			d.Headers = strings.Split(v, " ")[0]
		} else if strings.Contains(v, "body ") {
			d.Body = strings.Split(v, " ")[0]
		} else if strings.Contains(v, "query ") {
			d.Query = strings.Split(v, " ")[0]
		}
	}
	t, err := template.New("tpl").Parse(tpl)
	if err != nil {
		panic(err)
	}
	if err := t.Execute(dst, d); err != nil {
		panic(err)
	}
}

type HeadData struct {
	Line     string
	PkgName  string
	FileName string
}

func FuncHead(dst io.Writer, data HeadData) {
	const tpl = `
// Code generated by file {{.FileName}} and line {{.Line}} DO NOT EDIT.
// For more detail see https://github.com/wanglihui/restyless
package {{.PkgName}}
`
	t, err := template.New("tpl").Parse(tpl)
	if err != nil {
		panic(err)
	}
	if err := t.Execute(dst, data); err != nil {
		panic(err)
	}
}

type StructData struct {
	TypeName string
}

func StructTemplate(dst io.Writer, data StructData) {
	const tpl = `
func New{{.TypeName}}(r *resty.Client) *{{.TypeName}} {
	return &{{.TypeName}}{
		r : r,
	}
}

type {{.TypeName}}	struct {
	r *resty.Client
}
`
	t, err := template.New("tpl").Parse(tpl)
	if err != nil {
		panic(err)
	}
	if err := t.Execute(dst, data); err != nil {
		panic(err)
	}
}
